{"pages":[{"title":"404 Not Found——页面找不到了","text":"啊哦，页面找不到了，您可以【返回上一页】或【返回主页】 欢迎在评论区反馈来到404页面的经过！ 如果你来自目录/posts/XXX，那么非常抱歉，链接已更改为articles/XXX，例如/post/welcome已更改为/articles/welcome，/posts/How-many-hens已更改为/articles/How-many-hens。","link":"/404.html"}],"posts":[{"title":"Codeforces R622(Div.2)A 题解","text":"Codeforces Round #622 (Div. 2) A题【Fast Food Restaurant】题解 原题链接：Problem - A - Codeforces或CF1313A Fast Food Restaurant - 洛谷 | 计算机科学教育新生态 简化题意一共有3种食物A、B、C，每一种食物可以选至多1个或不选（也就是说要么不拿，要么只拿一个）。现在已知A,B,C各有多少份，在每个人都至少要拿任意一份食物时，问最多能派发给多少人。 思路 打表，因为数据范围小，勉勉强强还行 暴力，数据范围小，也比较简单 动规，这也是我们的重头戏 没错，动规！这道题其实可以看做多维费用背包（没见过的可以去OI-wiki恶补一下：Link），有3种东西，饭店持有的数量可以看做背包容量，而物品就需要枚举一下所有可能性，最后看最多能选多少物品。 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int cost[7][3]={{1,0,0},{0,1,0},{0,0,1},{1,1,0},{1,0,1},{0,1,1},{1,1,1}};//每种可能性各需要每种食物多少个int dp[20][20][20];int main(){ int t; cin&gt;&gt;t;//多组数据 while (t--) { memset(dp,0,sizeof(dp));//首先每次清零 int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;//输入每种食物各有多少个// dp[0][0][0]=1;//这个我一开始弄错了，在所有食物一个都没有时不应该有方案 for (int k=0;k&lt;7;k++)//背包模板 for (int ai=a;ai&gt;=cost[k][0];ai--)//因为每种食物只能选一次，故倒序（01背包） for (int bi=b;bi&gt;=cost[k][1];bi--) for (int ci=c;ci&gt;=cost[k][2];ci--) dp[ai][bi][ci]=max(dp[ai][bi][ci],dp[ai-cost[k][0]][bi-cost[k][1]][ci-cost[k][2]]+1);//背包动规，懂的自然懂 cout&lt;&lt;dp[a][b][c]&lt;&lt;endl;//在每种食物数量最多的时候肯定最优啦，输出~ } return 0;}","link":"/articles/CF-622-div2-A-sol/"},{"title":"Codeforces R624(Div.3)A 题解","text":"Codeforces Round #624 (Div. 3) A题【Add Odd or Subtract Even】题解 原题链接：Problem - 1311A - Codeforces或CF1311A Add Odd or Subtract Even - 洛谷 | 计算机科学教育新生态 咱们先稍微转一下，加上正奇数就改变了一个数的奇偶性，反之不变；而差为奇数说明两个数之间奇偶性不同，反之相同；另外，由于每次操作数字不限制，要多少有多少，所以我们的问题只剩下奇偶性问题。 再理一下情况：（有个typo，请见谅，如果无法加载请手动观看） 这还用说嘛 因为减法操作不会改变奇偶性，然而两数奇偶性不同，就要先把a减到$b-1$（$b-1$与a奇偶性相同，其实不一定减1，减任意一个奇数都行），再加个1（减多少，加多少） 因为减法操作不会改变奇偶性，而且两数奇偶性相同，就直接把a减到b 因为加法操作会改变奇偶性，而且两数奇偶性不同，就直接把a加到b 因为加法操作会改变奇偶性，而加到b以上后两数之差为奇数，可是只能减偶数，无解 怎么样，是不是像极了数学里令人作呕着迷的分类讨论呢？ 最后，上核心代码！ 1234567891011121314151617if (a==b) cout&lt;&lt;0;else if (a&lt;b){ if ((b-a)%2==0)// cout&lt;&lt;2; 这里一开始没考虑到无解，但是AC了o_O，大家自己改一改吧 else cout&lt;&lt;1;}else /*(a&gt;b)*/{ if ((b-a)%2==0) cout&lt;&lt;1; else cout&lt;&lt;2;}cout&lt;&lt;endl;//最后统一换行，减少码量","link":"/articles/CF-624-div3-A-sol/"},{"title":"Codeforces R626(Div.2)A 题解","text":"Codeforces Round #626 (Div. 2) A题【Even Subset Sum Problem】题解 原题链接：Problem - 1323A - Codeforces或CF1323A Even Subset Sum Problem - 洛谷 | 计算机科学教育新生态 这题还是很水的，跟着题意模拟就行了，但是我在review其他大佬的代码时，发现了一种稍微不一样的思路： 判断数组中有无偶数，有的话就他一个人构成一个子集 如果没有偶数，且数组中只有一个数（此时必为奇数），那么就他一个奇数，怎么也构不成偶数 如果数组由两个及以上的纯奇数组成，那么随便取两个就好啦，因为这时数组里只有奇数，奇数+奇数=偶数，为了方便，就固定取前两个 核心代码： 1234567891011121314151617181920212223int n;cin&gt;&gt;n;bool flag=false;for (int i=1;i&lt;=n;i++){ int ai; cin&gt;&gt;ai; if (ai%2==0&amp;&amp;!flag)//如果有偶数 { cout&lt;&lt;1&lt;&lt;endl;//当前这个就行了 cout&lt;&lt;i&lt;&lt;endl; flag=true;//标记一下，避免重复 }}if (flag)//避免重复 continue;if (n&lt;=1)//无解情况 cout&lt;&lt;-1&lt;&lt;endl;else{ cout&lt;&lt;2&lt;&lt;endl;//前两个之和必为偶数 cout&lt;&lt;1&lt;&lt;&quot; &quot;&lt;&lt;2&lt;&lt;endl;}","link":"/articles/CF-626-div2-A-sol/"},{"title":"多少母鸡？","text":"题目大意我同学给我发来了一道数学思维题，据说是某校分班考试题： 张伯伯和李伯伯一共有106只鸡，李的 $\\frac{3}{8}$ 是公鸡，张的 $\\frac{7}{11}$ 是母鸡，求张和李一共有多少只母鸡？ 条件梳理通过李的 $\\frac{3}{8}$ 是公鸡这一句话，我们不难看出李伯伯的鸡一共8份，其中3份公鸡，5份母鸡；张伯伯的鸡同理，于是得出下面一张表： 李 张 公 3 4 母 5 7 总 8 11 同样地，我们也可以将张伯伯的鸡看成8只一组，每组3公5母，张伯伯同理。（张伯伯：我怎么又同理꒰╬•᷅д•᷄╬꒱） 然后，假如把李伯伯的一组鸡换成张伯伯的，那么需要补：$$11-8=3（只）$$那么高潮来了！ 推导部分首先，不管公母，像上一部分一样把鸡看成N只一组，并把未归群的鸡抽象为野鸡。 李 张 野 0只 0只 106只 然后李伯伯把野鸡成组地捉回来：$$106\\div8=13（组）\\cdots\\cdots2（只）$$ 李 张 野 $13\\times8=104（只）$ 0只 2只 阔是，意外来了，李伯伯的一组鸡跑了！$$13-1=12（组）2+1\\times8=10（只）$$ 李 张 野 $12\\times8=96（只）$ 0只 10只 介个时候，张伯伯不乐意了：你把鸡全捉了，我呢？于是他找李伯伯谈判。最后张伯伯从野鸡中挑一些出来，和李伯伯给的（相对于李伯伯）整组的鸡放在一起。已知每组需要补3只，于是就捉了$$10\\div3=3（组）\\cdots\\cdots1（只）$$捉完3组，李伯伯也兑现了承诺：$$李：12-3=9（组）张：0+3=3（组）$$ 李 张 野 $9\\times8=72（只）$ $3\\times11=33（只）$ 1只 这时，李伯伯又跑了一组鸡（好粗心）$$9-1=8（组）1+1\\times8=9（只）$$ 李 张 野 $8\\times8=64（只）$ $3\\times11=33（只）$ 9只 另外，张伯伯还不满足，又向李伯伯提出同样要求，并且李伯伯同意了？！（真大方啊）$$9\\div3=3（组）$$ $$李：8-3=5（组）张：3+3=6（组）$$ 李 张 野 $5\\times8=40（只）$ $6\\times11=66（只）$ 0只 这时，没有野鸡啦ヽ(￣▽￣)ﾉ整个推导部分也就完毕。这时知道了组数，就很容易算出答案：$$5\\times5+6\\times7=67（只）$$ 验算像这种拿不稳的题目，一定要验算；即使拿得稳，也要尽量验算，确保正确。 李 张 和 公 $5\\times3=15（只）$ $6\\times4=24（只）$ $15+24=39（只）$ 母 $5\\times5=25（只）$ $6\\times7=42（只）$ $25+42=67（只）$ 和 $5\\times8=40（只）$ $6\\times11=66（只）$ $39+67=106（只）$ 完结撒花✿✿ヽ(°▽°)ノ✿ 总结大方不好 当一道数学题没有思路时，可以像这次一样将题目抽象化，实例化，寻找思路。","link":"/articles/How-many-hens/"},{"title":"洛谷题解 P1010 【幂次方】","text":"原题链接： P1010 幂次方 - 洛谷 | 计算机科学教育新生态 分析看各位大佬都用二进制等高端算法，蒟蒻都不会啊！QAQ只好用了最朴素的递归与模拟。 这里要理清这两点： 在分解一个数时，不能出现重复的，因为$2^x+2^x=2^{x+1}$。 分解出来的幂的指数要尽可能的大。 然后，程序的具体思路是： 先找一个尽可能大的幂。 特判，将指数为0和1的单独挑出来输出。 递归指数。 减去已经找到的幂次方数，返回第一步。 这样说可能有点迷，上代码更简单！ 核心代码123456789101112131415161718192021222324252627282930void dfs(int k)//传入一个数{ while (k!=0)//如果这个数还没有处理完 { int t=2,i;//指数为1 for (i=1;t&lt;=k;i++)//指数不断增加，直到当前幂次方已经大于k t*=2; i--; t/=2;//因为这时候t已经比k大了，所以指数减一 if (i==0)//如果指数为零 { cout&lt;&lt;&quot;2(0)&quot;; k-=1;//同k-=t goto last; } if (i==1)//如果指数为一 { cout&lt;&lt;&quot;2&quot;; k-=2;//同k-=t goto last; } cout&lt;&lt;&quot;2(&quot;; dfs(i);//递归指数// cout&lt;&lt;i;//可以把这一步取消注释，把上一步进行注释，观察指数未分解时是否正确 cout&lt;&lt;&quot;)&quot;; k-=t;//减去已经找到的幂次方数 last: if (k!=0) cout&lt;&lt;&quot;+&quot;;//如果k没处理完，输出加号 }}","link":"/articles/luogu-P1010-sol/"},{"title":"洛谷题解 P1028 【数的计算】","text":"原题链接： P1028 数的计算 - 洛谷 | 计算机科学教育新生态 分析一、这题不要想复杂了。这里在做的时候无需再前方加数可以直接传上次加的数进去。 二、作为Unaccepted过的OIer，本人得出一个经验：此题递归只能拿到25分（因耗时太长，后面15个点直接RE），所以要记住已计算过的数值。 代码方法一:递归1234567891011121314151617#include&lt;iostream&gt;using namespace std;int g;//记住有多少数。因为是全局变量，无需赋初值。void js(int s){ g++;//s本身也算一个数，所以g++ for (int i=1; i&lt;=s/2; i++)//循环计算 js(i);}int main(){ int n; cin&gt;&gt;n; js(n); cout&lt;&lt;g; return 0;} 此方法25分。 方法二：记忆化搜索123456789101112131415161718192021222324 #include&lt;iostream&gt; #include&lt;cstring&gt;//memset函数需要 using namespace std; int f[1005];//用数组来记忆 int js(int s)//“计算”函数 { if (f[s]!=-1)//如果f[s]的值不是-1，表示数s已被计算 return f[s];//所以直接输出 int g=1;//g=1是因为s本身也算一个数 for (int i=1; i&lt;=s/2; i++)//循环计算 g+=js(i); f[s]=g;//记住s的值 return g;//返回 } int main() { int n; cin&gt;&gt;n;// memset(f,-1,sizeof(f));//将f赋初值为-1.//上面方法较为危险（因为memset是按字节格式化的）//为了安全起见请使用循环大法，这里不再赘述 cout&lt;&lt;js(n); return 0; } 此方法满分。 经过讲解是不是很简单呢？","link":"/articles/luogu-P1028-sol/"},{"title":"洛谷题解 P1051 【谁拿了最多奖学金】","text":"原题链接： P1051 谁拿了最多奖学金 - 洛谷 | 计算机科学教育新生态 这题虽然是NOIP2005提高组t1，不过难度甚至连 普及- 都不到。此题根本无需STL排序，不知为各位为何大佬都写这么多，我这位蒟蒻的代码只有30多行。 此题只需读一个数据处理一个即可，既省时间，又省内存。代码如下： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;//头文件#include&lt;cstring&gt;using namespace std;int main(){ int n,maxn=0,ans=0;//maxn为最大奖学金的总数，ans是所有人奖学金的总数 char s[25];//获得最多奖学金的人的姓名 cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) { char name[25],tf_s,tf_x;//name姓名，tf_s学生干部，tf_x西部省份学生 int score_p,score_c,l,money=0;//score_p期末平均成绩，score_c班级评议成绩，money学生奖学金的数量 cin&gt;&gt;name&gt;&gt;score_p&gt;&gt;score_c&gt;&gt;tf_s&gt;&gt;tf_x&gt;&gt;l; if (score_p&gt;80&amp;&amp;l&gt;=1)//期末平均成绩高于80分 money+=8000; if (score_p&gt;85&amp;&amp;score_c&gt;80)//期末平均成绩高于85分，班级评议成绩高于80分 money+=4000; if (score_p&gt;90)//期末平均成绩高于90分 money+=2000; if (score_p&gt;85&amp;&amp;tf_x=='Y')//期末平均成绩高于85分的西部省份学生 money+=1000; if (score_c&gt;80&amp;&amp;tf_s=='Y')//班级评议成绩高于80分的学生干部 money+=850; ans+=money;//总钱数累加 if (money&gt;max)//如果奖学金最多 { max=money;//最多奖学金数量为当前奖学金 strcpy(s,name);//复制名字 } } cout&lt;&lt;s&lt;&lt;endl&lt;&lt;max&lt;&lt;endl&lt;&lt;ans;//输出 return 0;} 目测别人的时间复杂度：$O(n log_2 n)$（因为快排） 我的：$O(n)$ 目测别人的辅助空间：$O(n)$ 我的：$O(1)$ 因为本人还是个新手OIer，发表的题解还有许多不足之处，如果有人指出，本人将虚心接受。","link":"/articles/luogu-P1051-sol/"},{"title":"洛谷题解 P1138 【第k小整数】","text":"原题链接： P1028 第k小整数 - 洛谷 | 计算机科学教育新生态 STL大法吼啊！ 分析这道题有两个步骤：排序、去重。 解决这个问题的方法有很多：sort+遍历去重、unique、其他高端数据结构等。我本来想选第一种方法的，后来我突然想起有一种STL可以自动去重+排序，那就是set，那岂不是很简单？（美滋滋）结果更难了 SET用法解析需要包含的头文件： 1#include&lt;set&gt; 它的定义方法： 123set&lt;type&gt; name;//例子：定义int型，取名为aset&lt;int&gt; a; 我们要用到的函数： 1234iterator begin(); //指向第一个元素的迭代器iterator end(); //指向最后一个元素的迭代器pair insert(const type &amp;val); //在集合中插入val元素，并返回指向该元素的迭代器和一个布尔值来说明val是否成功的被插入了size_type size(); //返回元素数目 遍历方法： 1234567int cnt=0;//用于记录遍历到第几个了for (set&lt;int&gt;::iterator i=a.begin();i!=a.end();i++){ cnt++; if (cnt==k)//达到终点 cout&lt;&lt;*i;} 更多STL工具见文末！ 应用在此题中首先，我们可以使用insert函数用来插入元素。然后使用size来判断元素够不够 k 个，最后按照上文的方法进行遍历即可！ 本文代码： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;set&lt;int&gt; a;//定义集合int main(){ int n,k; cin&gt;&gt;n&gt;&gt;k; for (int i=1;i&lt;=n;i++) { int x; cin&gt;&gt;x; a.insert(x);//插入元素 } if (a.size()&gt;=k)//判断元素数量是否足够 { int cnt=0;//标记遍历到了第几个 for (set&lt;int&gt;::iterator i=a.begin();i!=a.end();i++)//遍历 { cnt++; if (cnt==k)//到达目的地 cout&lt;&lt;*i;//输出 } } else cout&lt;&lt;&quot;NO RESULT&quot;;//输出无解 return 0;//完结撒花ヽ(≧∀≦)ﾉ} 附：c&amp;cppAPI.chm","link":"/articles/luogu-P1138-sol/"},{"title":"洛谷题解 P1420 【最长连号】","text":"原题链接： P1420 数的计算 - 洛谷 | 计算机科学教育新生态 此题其实不用数组也能通过，只不过稍微有些难理解。 定义两个变量a,b。其中，a表示上一个数，b表示新读入的数。 按样例来说，a,b的交替是这样的： 10 3 5 6 2 3 4 5 6 8 9 i 1 2 3 4 5 6 7 8 9 10 a 3 3 5 6 2 3 4 5 6 8 b 5 6 2 3 4 5 6 8 9 代码如下： 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main(){ int n,a,b,s=1,maxn=0;//s代表当前连续长度，默认为1（因为第一个自己也算一个）；maxn代表最大连续长度。 cin&gt;&gt;n; cin&gt;&gt;a;//输入第一个数 for (int i=2; i&lt;=n; i++)//注意从第二个数开始，因为第一个已读过 { cin&gt;&gt;b;//输入当前数 if (b-a==1)//如果与上一个数相差1 s++;//当前连续长度+1 else { if (s&gt;maxn)//如果当前连续长度（不算自己）比最大连续长度长 maxn=s;//更新最大连续长度 s=1;//初始化（自己也算一个！） } a=b;//成为即将的“上一个数” } cout&lt;&lt;maxn; return 0;}","link":"/articles/luogu-P1420-sol/"},{"title":"洛谷题解 P1618 【三连击（升级版）】","text":"原题链接： P1618 三连击（升级版） - 洛谷 | 计算机科学教育新生态 其实这题挺简单，没做过的先去试试【P1008】三连击 分析思路与P1008相同。 具体思路： 一、枚举1~999的所有数为第一个数，然后分别乘$a,b,c$。这就省去了三重循环，变为一重，在数据非常大时效果更明显。（其实无需循环至999，只是懒得算了而已） 二、定义一个数组，记录1~9的使用量。 代码1.0版1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int jishu(int n)//统计出现了多少数{ int m[10],s=0; memset(m,0,sizeof(m));//初始化数组 while (n!=0)//剥离数字并记录 { m[n%10]++; n/=10; } for (int j=0; j&lt;=9; j++)//记录出现了多少种数字 if (m[j]&gt;=1) s++; return s;}int main(){ int a,b,c; bool o=false;//假设没有找到 cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;//输入 for (int i=111; i&lt;=999; i++)//循环 { int x,y,z; x=i*a; y=i*b; z=i*c; if (x&lt;=999&amp;&amp;y&lt;=999&amp;&amp;z&lt;=999)//如果三个数均为三位数 if (jishu(x*1000000+y*1000+z)==9)//统计出现了多少数 { cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;//输出 o=true;//我找到了！！！ } } if (o==false)//如果没找到 cout&lt;&lt;&quot;No!!!&quot;;//输出我没找到。 return 0;} 这个方法只能得60分。为什么呢？看case#1 input： 1 2 3 answer： 192 384 576 219 438 657 273 546 819 327 654 981 output: 192 384 576 219 438 657 267 534 801 273 546 819 327 654 981 看到267 534 801了吗？是0惹的祸。0本身是不应该算进去的。 2.0版1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int jishu(int n){ int m[10],s=0; memset(m,0,sizeof(m)); while (n!=0) { m[n%10]++; n/=10; } for (int j=1; j&lt;=9; j++)//从1开始 if (m[j]&gt;=1) s++; return s;}int main(){ int a,b,c; bool o=false; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; for (int i=111; i&lt;=999; i++) { int x,y,z; x=i*a; y=i*b; z=i*c; if (x&lt;=999&amp;&amp;y&lt;=999&amp;&amp;z&lt;=999) if (jishu(x*1000000+y*1000+z)==9) { cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl; o=true; } } if (o==false) cout&lt;&lt;&quot;No!!!&quot;; return 0;} 总体思路差不多，我就不多说了。可是一提交80了。再看case#5 input: 123 456 789 answer: 123 456 789 output: （空） 有可能$a,b,c$是多位数啊！应该循环从1就开始 3.0版1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int jishu(int n)//统计出现了多少数{ int m[10],s=0; memset(m,0,sizeof(m));//初始化数组 while (n!=0)//剥离数字并记录 { m[n%10]++; n/=10; } for (int j=1; j&lt;=9; j++)//记录出现了多少种数字（从1开始！！！） if (m[j]&gt;=1) s++; return s;}int main(){ int a,b,c; bool o=false;//假设没有找到 cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; for (int i=1; i&lt;=999; i++)//循环（从1开始！！！） { int x,y,z; x=i*a; y=i*b; z=i*c; if (x&lt;=999&amp;&amp;y&lt;=999&amp;&amp;z&lt;=999)//如果三个数均为三位数 if (jishu(x*1000000+y*1000+z)==9)//统计出现了多少种数 { cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl; o=true;//我找到了！！！ } } if (o==false)//如果没找到 cout&lt;&lt;&quot;No!!!&quot;; return 0;} 终于AC了！","link":"/articles/luogu-P1618-sol/"},{"title":"OJ常见评测状态","text":"OJ(Online Judge，在线测评系统)中有许多评测状态，许多新手都看不懂。今天让我们来看一看一些常用的评测状态。 各种常见评测状态 英文全拼 英文简写 中文 解释/解决方法 Waiting WT （正在）等待 你的代码在等待评测 。 Compiling —— （正在）编译 你的代码正在被编译。 Running/Judging RU/JU 正在运行&amp;评测 你的代码在运行&amp;评测 。 Accepted AC 通过评测 你的代码没有问题，已通过评测。 Compile Error CE 编译错误 你的代码编译错误，请检查语法。 Wrong Answer WA 答案错误 仅用样例测试的程序不一定正确，一定还有忽略的或没想到的地方。 Presentation Error PE 格式错误 格式错误。再看一下题目中对格式的要求。 Time Limit Exceeded TLE 时间超限 时间超出限制。检查一下是否有死循环或更快的方法。 Memory Limit Exceeded MLE 内存超限 内存超出限制。变量数量可能需要压缩。 Runtime Error RE 运行时错误 即传说中的崩溃。非法的内存访问，数组越界 等都有可能造成。 Output Limit Exceeded OLE 输出超限 输出超出限制。你输出的东西太多了。（不常见） Unknown Error UKE 未知错误 出现未知错误。最玄学的一种。（不常见） 本地由于编译器与运行环境不同，有可能部分代码会出现“本地通过，提交错误的情况”。","link":"/articles/oj-status/"}],"tags":[{"name":"OI题解","slug":"OI题解","link":"/tags/OI%E9%A2%98%E8%A7%A3/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"精品文章","slug":"精品文章","link":"/tags/%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/"},{"name":"数学题解","slug":"数学题解","link":"/tags/%E6%95%B0%E5%AD%A6%E9%A2%98%E8%A7%A3/"},{"name":"数学思维题","slug":"数学思维题","link":"/tags/%E6%95%B0%E5%AD%A6%E6%80%9D%E7%BB%B4%E9%A2%98/"},{"name":"洛谷","slug":"洛谷","link":"/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"OI笔记","slug":"OI笔记","link":"/tags/OI%E7%AC%94%E8%AE%B0/"},{"name":"小知识","slug":"小知识","link":"/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"categories":[{"name":"OI题解","slug":"OI题解","link":"/categories/OI%E9%A2%98%E8%A7%A3/"},{"name":"数学题解","slug":"数学题解","link":"/categories/%E6%95%B0%E5%AD%A6%E9%A2%98%E8%A7%A3/"},{"name":"OI笔记","slug":"OI笔记","link":"/categories/OI%E7%AC%94%E8%AE%B0/"}]}